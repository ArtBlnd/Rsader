#![allow(dead_code)]
#![allow(unused_imports)]
use crate::ast::*;
use crate::currency::Currency;
use rust_decimal::Decimal;

grammar<'input>;

extern {
    type Location = usize;
    type Error = ParseError;

    enum Token<'input> {
        Let => Token::Let,
        Fn => Token::Fn,
        Struct => Token::Struct,
        Enum => Token::Enum,
        Async => Token::Async,
        Await => Token::Await,
        Drop => Token::Drop,
        If => Token::If,
        Else => Token::Else,
        While => Token::While,
        For => Token::For,
        Trait => Token::Trait,
        CurrencyPair => Token::CurrencyPair(<(Currency, Currency)>),
        Currency => Token::Currency(<Currency>),
        Text => Token::Text(<&'input str>),
        String => Token::String(<&'input str>),
        Boolean => Token::Boolean(<bool>),
        Integer => Token::Integer(<u128>),
        Decimal => Token::Decimal(<Decimal>),
        "#" => Token::Sharp,
        "@" => Token::At,
        "*" => Token::Asterisk,
        "/" => Token::Slash,
        "." => Token::Dot,
        "[" => Token::LBracket,
        "]" => Token::RBracket,
        "<" => Token::Lt,
        ">" => Token::Gt,
        "<=" => Token::Le,
        ">=" => Token::Ge,
        "==" => Token::Eq,
        "!=" => Token::Ne,
        "(" => Token::LParen,
        ")" => Token::RParen,
        "{" => Token::LBrace,
        "}" => Token::RBrace,
        "$" => Token::Dollar,
        "+" => Token::Add,
        "-" => Token::Sub,
        "," => Token::Comma,
        ":" => Token::Colon,
        "::" => Token::DoubleColon,
        ";" => Token::Semicolon,
        "|" => Token::BitwiseOr,
        "&" => Token::BitwiseAnd,
        "||" => Token::LogicalOr,
        "&&" => Token::LogicalAnd,
        "=" => Token::Assign,
        "->" => Token::RArrow,
    }
}

Literal: Literal = {
    <currency:Currency> => Literal::Currency(currency),
    <num:Decimal> => Literal::Decimal(Decimal::from(num)),
    <num:Integer> => Literal::Integer(num),
    <bool:Boolean> => Literal::Boolean(bool),
    <str:String> => Literal::String(str.trim_matches('"').to_string()),
    <pair:CurrencyPair> => Literal::CurrencyPair(pair),
}

OptionalGenericParam: Vec<Ty<'input>> = {
    "::" "<" <params:List<Ty>> ">" => params,
    => vec![],
}

Term: Expr<'input> = {
    #[precedence(level="0")]
    Async <expr: Term> => Expr::Async(Box::new(expr)),
    Await <expr: Term> => Expr::Await(Box::new(expr)),

    #[precedence(level="1")]
    "(" <items: List<Expr>> ")" => {
        if items.len() == 1 {
            items[0].clone()
        } else {
            Expr::Tuple { items }
        }
    },
    "{" <items: List<Stmt>> "}" => Expr::Block(items),

    #[precedence(level="2")]
    <literal: Literal> => Expr::Literal(literal),
    <name: Ident> => Expr::Identifier { name },

    #[precedence(level="3")] #[assoc(side="left")]
    <expr: Term> "." <field: Ident> => Expr::FieldAccess { expr: Box::new(expr), field },

    #[precedence(level="4")] #[assoc(side="left")]
    <expr: Term> <args0: OptionalGenericParam> "(" <args1: List<Expr>> ")" => Expr::Call { expr: Box::new(expr), args0, args1 },
}

pub Expr: Expr<'input> = {
    #[precedence(level="0")]
    Term,

    #[precedence(level="1")] #[assoc(side="left")]
    <lhs: Expr> "*" <rhs: Expr> => Expr::BinOp { op: BinaryOp::Arithmetic(BinaryArithmeticOp::Mul), lhs: Box::new(lhs), rhs: Box::new(rhs) },
    <lhs: Expr> "/" <rhs: Expr> => Expr::BinOp { op: BinaryOp::Arithmetic(BinaryArithmeticOp::Div), lhs: Box::new(lhs), rhs: Box::new(rhs) },

    #[precedence(level="2")] #[assoc(side="left")]
    <lhs: Expr> "+" <rhs: Expr> => Expr::BinOp { op: BinaryOp::Arithmetic(BinaryArithmeticOp::Add), lhs: Box::new(lhs), rhs: Box::new(rhs) },
    <lhs: Expr> "-" <rhs: Expr> => Expr::BinOp { op: BinaryOp::Arithmetic(BinaryArithmeticOp::Sub), lhs: Box::new(lhs), rhs: Box::new(rhs) },

    #[precedence(level="3")] #[assoc(side="left")]
    <lhs: Expr> "&" <rhs: Expr> => Expr::BinOp { op: BinaryOp::Bitwise(BinaryBitwiseOp::And), lhs: Box::new(lhs), rhs: Box::new(rhs) },
    #[precedence(level="4")] #[assoc(side="left")]
    <lhs: Expr> "|" <rhs: Expr> => Expr::BinOp { op: BinaryOp::Bitwise(BinaryBitwiseOp::Or), lhs: Box::new(lhs), rhs: Box::new(rhs) },
    
    #[precedence(level="5")] #[assoc(side="left")]
    <lhs: Expr> "<" <rhs: Expr> => Expr::BinOp { op: BinaryOp::Comparison(BinaryComparisonOp::Lt), lhs: Box::new(lhs), rhs: Box::new(rhs) },
    <lhs: Expr> ">" <rhs: Expr> => Expr::BinOp { op: BinaryOp::Comparison(BinaryComparisonOp::Gt), lhs: Box::new(lhs), rhs: Box::new(rhs) },
    <lhs: Expr> "<=" <rhs: Expr> => Expr::BinOp { op: BinaryOp::Comparison(BinaryComparisonOp::Le), lhs: Box::new(lhs), rhs: Box::new(rhs) },
    <lhs: Expr> ">=" <rhs: Expr> => Expr::BinOp { op: BinaryOp::Comparison(BinaryComparisonOp::Ge), lhs: Box::new(lhs), rhs: Box::new(rhs) },
    <lhs: Expr> "==" <rhs: Expr> => Expr::BinOp { op: BinaryOp::Comparison(BinaryComparisonOp::Eq), lhs: Box::new(lhs), rhs: Box::new(rhs) },
    <lhs: Expr> "!=" <rhs: Expr> => Expr::BinOp { op: BinaryOp::Comparison(BinaryComparisonOp::Ne), lhs: Box::new(lhs), rhs: Box::new(rhs) },
    
    #[precedence(level="6")] #[assoc(side="left")]
    <lhs: Expr> "&&" <rhs: Expr> => Expr::BinOp { op: BinaryOp::Logical(BinaryLogicalOp::And), lhs: Box::new(lhs), rhs: Box::new(rhs) },
    #[precedence(level="7")] #[assoc(side="left")]
    <lhs: Expr> "||" <rhs: Expr> => Expr::BinOp { op: BinaryOp::Logical(BinaryLogicalOp::Or), lhs: Box::new(lhs), rhs: Box::new(rhs) },

    #[precedence(level="8")] #[assoc(side="left")]
    <lhs: Expr> "=" <rhs: Expr> => Expr::BinOp { op: BinaryOp::Assign, lhs: Box::new(lhs), rhs: Box::new(rhs) },
}

NameAndTy: Vec<NameAndTy<'input>> = {
    <name:Ident> ":" <ty:Ty> => vec![NameAndTy { name, ty }],
    <name:Ident> ":" <ty:Ty> "," <tail:NameAndTy> => {
        let mut args = tail;
        args.insert(0, NameAndTy { name, ty });
        args
    },
}

Variant: Variant<'input> = {
    <name:Ident> => Variant::Unit(name),
    <name:Ident> "{" <fields:NameAndTy> "}" => Variant::Struct(name, fields),
}

Item: Item<'input> = {
    Fn <name:Ident> <args0:OptionalGenericParam> "(" <args1:NameAndTy> ")" "{" <body:List<Stmt>> "}" => Item::Function { name, args0, args1, body },
    Struct <name:Ident> "{" <fields:NameAndTy> "}" => Item::Struct { name, fields },
    Enum <name:Ident> "{" <variants:List<Variant>> "}" => Item::Enum { name, variants },
}

OptionalAssign : Option<Expr<'input>> = {
    "=" <expr:Expr> => Some(expr),
    => None,
}

Ident: Ident<'input> = {
    <ident:Text> => Ident(ident),
}

Ty: Ty<'input> = {
    <ident:Text> => Ty(ident),
}

List<T>: Vec<T> = {
    <head:T> "," <tail:List<T>> => {
        let mut list = tail;
        list.insert(0, head);
        list
    },
    <head:T> => vec![head],
    => vec![],
}

OptionalTy: Option<Ty<'input>> = {
    ":" <ty:Ty> => Some(ty),
    => None,
}

pub Stmt: Stmt<'input> = {
    #[precedence(level="0")]
    ";" => Stmt::Empty,

    #[precedence(level="1")] #[assoc(side="left")]
    Let <name:Ident> <ty: OptionalTy> <expr: OptionalAssign> => Stmt::Let(Let { name, ty, expr }),

    #[precedence(level="2")]
    <item:Item> => Stmt::Item(item),
    <expr:Expr> => Stmt::Expr(expr),
}